# Job Scheduling with Multiple Machines

A simulated annealing solver is implemented in Julia to solve the Parallel Machine Scheduling Problem (Group 3, Case 3).

## Problem description
- A set of jobs $J=\{1,2,\dots,n\}$ with corresponding processing times $p_j$.
- A set of machines $M=\{1,2,\dots,k\}$.

### Objective
Find an assignment of jobs to machines that minimizes the **makespan**, i.e., the maximum completion time among all machines.

## Usage
Run from the command line: `julia scheduling.jl <instance-file> <time-limit-seconds> <seed>`

### Program Parameters
- `<instance-file>`: Path to the input problem instance.
- `<time-limit-seconds>`: Computational time limit in seconds.
- `<seed>`: Seed for the random number generator, ensuring reproducibility of results.

## Solution Representation
The algorithm works with an **indirect solution representation** in the form of a **permutation of all jobs**. Each permutation is decoded into an actual schedule using the **list scheduling** procedure, where jobs are planned one after another on a machine with the currently least load. This guarantees that every permutation corresponds to a feasible solution. Because list scheduling is a greedy procedure, the decoded schedules are already relatively good. Moreover, there always exists an optimal solution that can be represented in this way (such a permutation can be generated by taking an optimal solution and sorting the jobs according to their start times).

## Neighborhood Structure
The neighborhood is defined by **swap moves** on the permutation (exchanging two jobs). This neighborhood is **connected**, i.e., any permutation can be reached from any other by a finite sequence of swaps. Furthermore, neighbor solutions are always valid, so the search can intensively explore large parts of the solution space. To diversify, a random partial shuffle of the permutation is applied after a large number of non‑improving iterations.

## Algorithm Outline
1. **Initial solution**: Jobs are sorted in decreasing order by their processing times and decoded using list scheduling, yielding a **4/3‑approximation guarantee** for the optimal makespan. 
2. **Main loop**:  
   - Neighbor solutions are generated by swapping jobs in the permutation.
   - A **simulated annealing acceptance criterion** allows occasional acceptance of worse solutions to escape local minima, while improving neighbor solutions are always accepted.
   - A **dynamic geometric cooling schedule** adapts the temperature such that a final target temperature (scaled by the objective value) is reached within the time limit.
   - After many non‑improving iterations, a **random partial shuffle** diversifies the search.
3. **Termination**: The best solution found within the given time limit is returned.
